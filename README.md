<div dir="rtl">

# آزمایش دوم - سیستم پرداخت

---

## مرحله 1:

### گزارش Code Smells

#### Code Smells شناسایی‌شده

#### 1. **کلاس بزرگ (Big Class, God Class)**
- کلاس `PaymentProcessor` دارای وظایف متعددی است، از جمله اعتبارسنجی، پردازش پرداخت و ثبت تراکنش، که باعث افزایش پیچیدگی و کاهش خوانایی کد می‌شود.

#### 2. **متد طولانی (Long Method)**
- متد `processPayment` شامل چندین وظیفه مختلف است که باعث دشوار شدن نگهداری و درک آن می‌شود.

#### 3. **استفاده بیش از حد از Switch (Excessive Switch Statement)**
- متد `processPayment` از یک `switch-case` برای مدیریت انواع مختلف پرداخت استفاده می‌کند که گسترش کد را سخت می‌کند.

#### 4. **کد تکراری (Duplicated Code)**
- منطق پردازش پرداخت برای روش‌های مختلف مانند کارت اعتباری، کیف پول دیجیتال و انتقال بانکی مشابه است و باعث تکرار غیرضروری کد شده است.

#### 5. **Primitive Obsession (وابستگی بیش از حد به انواع اولیه)**
- اطلاعات مشتری و پرداخت به‌صورت `Map<String, String>` ذخیره شده‌اند که باعث کاهش خوانایی و ایمنی نوع داده‌ها می‌شود.

#### 6. **Hardcoded Configuration (پیکربندی هاردکد شده)**
- مقادیر مربوط به APIهای پرداخت مستقیماً در کلاس `PaymentProcessor` قرار داده شده‌اند که باعث وابستگی بالا و کاهش انعطاف‌پذیری کد می‌شود.

#### 7. **Magic Strings (رشته‌های جادویی)**
- مقادیر ثابت مانند `"USD"`, `"EUR"`, `"GBP"` در کد به‌صورت رشته‌های جادویی استفاده شده‌اند. این نوع داده‌ها در صورت اشتباه تایپ، ممکن است به‌طور خاموشی منجر به خطا شوند. استفاده از **ثابت‌ها** یا **enum** برای این مقادیر، ایمنی کد را افزایش می‌دهد.

#### 8. **Lack of Unit Tests (عدم وجود تست‌های واحد)**
- طراحی فعلی، وابستگی شدید به پیاده‌سازی دارد که باعث دشوار شدن تست‌نویسی می‌شود.


### نقض اصول SOLID

#### 1. **Single Responsibility Principle (SRP)**

- کلاس `PaymentProcessor` علاوه بر پردازش پرداخت، مسئولیت‌هایی مانند ثبت تراکنش‌ها و اعتبارسنجی را نیز بر عهده دارد.
- این مسئله موجب می‌شود که هر تغییری در یکی از این بخش‌ها، عملکرد کلی کلاس را تحت تأثیر قرار دهد. این موضوع نه‌تنها نگهداری کد را سخت‌تر می‌کند، بلکه احتمال بروز خطا در قسمت‌های دیگر را نیز افزایش می‌دهد.

#### 2. **Open/Closed Principle (OCP)**
- در صورت اضافه شدن یک روش پرداخت جدید (مثلاً "crypto")، باید `processPayment` و `validatePayment` تغییر کنند.
- این امر باعث تغییر مستقیم در کلاس اصلی می‌شود که منجر به افزایش احتمال بروز باگ در عملکردهای دیگر خواهد شد. در عوض، روش‌های جدید پرداخت باید بدون تغییر در کلاس `PaymentProcessor` اضافه شوند.

#### 3. **Liskov Substitution Principle (LSP)**
- به‌طور مستقیم نقض نشده است، اما پردازش پرداخت به منطق خاصی در `PaymentProcessor` وابسته است.
- در حال حاضر، استفاده از `switch-case` باعث شده است که اگر بخواهیم یک کلاس جایگزین برای پردازش پرداخت ارائه دهیم، نتواند به راحتی با منطق فعلی جایگزین شود. این موضوع باعث می‌شود که کلاس‌های جدید با محدودیت‌های غیرضروری مواجه شوند.

#### 4. **Interface Segregation Principle (ISP)**
- هیچ واسطی (Interface) تعریف نشده است، اما تمام روش‌های پرداخت باید از یک متد پردازش استفاده کنند، حتی اگر برخی از آنها به تمام پارامترها نیازی نداشته باشند.
- این موضوع باعث می‌شود که کلاس‌هایی که فقط به یک بخش از عملکرد نیاز دارند، مجبور به پیاده‌سازی متدهایی شوند که برای آن‌ها ضروری نیست. این کار باعث افزایش پیچیدگی و کاهش خوانایی کد می‌شود.

#### 5. **Dependency Inversion Principle (DIP)**
- کلاس `PaymentProcessor` مستقیماً به متدهای پردازش سطح پایین مانند `processCreditCard` وابسته است.
- این وابستگی مستقیم به پیاده‌سازی‌های سطح پایین باعث سخت‌تر شدن تغییر و جایگزینی روش‌های پردازش پرداخت می‌شود. بهتر است کلاس `PaymentProcessor` به جای وابستگی مستقیم به این متدها، به یک اینترفیس عمومی برای روش‌های پرداخت وابسته باشد.


## مرحله 2:

# مستندات کد بازآرایی شده

این مستند توضیحاتی درباره‌ی بازآرایی سیستم پرداخت ارائه می‌دهد که در آن از اصول شیءگرایی مانند انتزاع، وراثت و چندریختی استفاده شده است. هدف از این بازآرایی جداسازی منطق‌های پرداخت، اعتبارسنجی و پردازش پرداخت از یکدیگر و بهبود قابلیت توسعه و نگهداری کد می‌باشد.

## اهداف و مزایا

- **کپسوله‌سازی:**
  - جدا کردن ویژگی‌های مشترک پرداخت‌ها در کلاس انتزاعی **Payment**.
  - جداسازی منطق‌های اعتبارسنجی و پردازش هر نوع پرداخت در کلاس‌های مجزا.

- **انتزاع و وراثت:**
  - استفاده از کلاس انتزاعی **Payment** برای تعریف ویژگی‌های عمومی (مانند مبلغ، ارز، زمان ثبت، اطلاعات مشتری و جزئیات پرداخت).
  - ایجاد زیرکلاس‌هایی مانند **CreditCardPayment**، **DigitalWalletPayment** و **BankTransferPayment** که منطق اعتبارسنجی و پردازش مختص خود را پیاده‌سازی می‌کنند.

- **جداسازی نگرانی‌ها:**
  - کلاس **PaymentProcessor** تنها مسئول هماهنگی و ثبت تراکنش‌های پرداخت است.
  - منطق پردازش و اعتبارسنجی به کلاس‌های جداگانه انتقال یافته است.

## ساختار کد

### 1. کلاس انتزاعی Payment

- **هدف:**
  - تعریف ویژگی‌ها و رفتارهای مشترک بین انواع پرداخت.
  
- **ویژگی‌ها:**
  - `amount`: مبلغ پرداخت  
  - `currency`: ارز مورد استفاده  
  - `timestamp`: زمان ثبت پرداخت  
  - `customerInfo`: اطلاعات مشتری (مانند نام و ایمیل)  
  - `paymentDetails`: جزئیات خاص مربوط به نوع پرداخت (مانند شماره کارت، wallet id، یا شماره حساب)

- **متدهای انتزاعی:**
  - `validatePayment()`: متدی برای اعتبارسنجی پرداخت که توسط زیرکلاس‌ها پیاده‌سازی می‌شود.
  - `processPayment(Map<String, String> config)`: متدی برای پردازش پرداخت از طریق اتصال به APIهای شخص ثالث.

### 2. زیرکلاس‌های Payment

برای هر نوع پرداخت، زیرکلاس‌های متفاوتی ایجاد شده‌اند:

- **CreditCardPayment:**
  - **اعتبارسنجی:** بررسی مبلغ مثبت، ارز معتبر، وجود ایمیل مشتری و بررسی طول شماره کارت (حداقل ۱۲ رقم).
  - **پردازش:** اتصال به API مربوط به کارت‌های اعتباری و تولید شناسه تراکنش منحصر به فرد.

- **DigitalWalletPayment:**
  - **اعتبارسنجی:** بررسی مبلغ، ارز معتبر، وجود ایمیل مشتری و وجود wallet_id در جزئیات پرداخت.
  - **پردازش:** اتصال به API کیف پول دیجیتال و تولید شناسه تراکنش.

- **BankTransferPayment:**
  - **اعتبارسنجی:** بررسی مبلغ، ارز معتبر، وجود ایمیل مشتری و وجود شماره حساب بانکی در جزئیات پرداخت.
  - **پردازش:** اتصال به API انتقال بانکی و تولید شناسه تراکنش.

### 3. کلاس PaymentProcessor

- **هدف:**
  - هماهنگی پردازش پرداخت‌ها.
  
- **وظایف:**
  - دریافت یک شیء از نوع **Payment** (که می‌تواند هر یک از زیرکلاس‌های آن باشد).
  - اعتبارسنجی پرداخت با استفاده از متد `validatePayment()`.
  - پردازش پرداخت با فراخوانی متد `processPayment()` مربوط به شیء Payment.
  - ثبت تراکنش با ثبت جزئیات پردازش در خروجی (logging).

## مزایای طراحی

- **افزودن انواع پرداخت جدید:**
  - با ایجاد یک زیرکلاس جدید از **Payment** و پیاده‌سازی منطق مربوط به آن، می‌توان به راحتی سیستم را گسترش داد.
  
- **جداسازی منطق‌های مختلف:**
  - اعتبارسنجی و پردازش پرداخت به کلاس‌های جداگانه منتقل شده‌اند که باعث بهبود قابلیت نگهداری و تست کد می‌شود.
  
- **سادگی و وضوح:**
  - استفاده از کلاس‌های انتزاعی و زیرکلاس‌های مشخص، کد را خواناتر و مدیریت آن را ساده‌تر می‌کند.





## مرحله 3


#  پیاده‌سازی رابط PaymentGateway با استفاده از وراثت و چندریختی

## هدف
هدف این بخش از پروژه جداسازی منطق پرداخت از منطق یکپارچه‌سازی با درگاه‌های پرداخت خارجی است. این کار با طراحی یک رابط (interface) به نام `PaymentGateway` انجام می‌شود تا هر درگاه پرداخت بتواند نسخه مخصوص به خود را پیاده‌سازی کند. این رویکرد باعث افزایش انعطاف‌پذیری و قابلیت گسترش سیستم می‌شود.

## مزایا

- افزایش خوانایی و نگه‌داری‌پذیری کد
- سهولت در افزودن درگاه‌های جدید بدون تغییر در منطق اصلی
- استفاده از مفاهیم شی‌گرایی مانند چندریختی (Polymorphism) برای تعویض آسان درگاه‌ها در زمان اجرا
- امکان تست آسان ماژول‌ها به صورت مستقل

## ساختار کلاس‌ها

### PaymentGateway (رابط)
- تعریف متدهای مشترک برای تمام درگاه‌ها:
  - `processPayment(...)`
  - `refundPayment(...)`
  - `getTransactionStatus(String transactionId)`
- جداسازی منطق کلی از پیاده‌سازی‌های خاص هر درگاه

### StripeGateway
- پیاده‌سازی رابط `PaymentGateway` با منطق مربوط به درگاه Stripe
- استفاده از endpoint و کلید API مخصوص Stripe
- شبیه‌سازی تراکنش و تولید ID مخصوص

### PayPalGateway
- پیاده‌سازی رابط `PaymentGateway` برای درگاه PayPal
- تعامل با endpoint مخصوص PayPal و شبیه‌سازی پرداخت
- تولید transaction ID منحصر به PayPal

### BaseGateway (اختیاری)
- کلاس پایه مشترک برای کدهای تکراری بین درگاه‌ها
- نگه‌داری پیکربندی‌ها و متدهای کمکی (مانند تولید transactionId)

### PaymentProcessor
- دریافت شیء از نوع `PaymentGateway` (به‌جای درگاه خاص)
- ارسال درخواست پردازش، بازپرداخت و بررسی وضعیت از طریق متدهای رابط
- بدون اطلاع از نوع واقعی درگاه، فقط از طریق interface با آن تعامل می‌کند

### PaymentGatewayDemo
- نمونه‌سازی از `StripeGateway` و `PayPalGateway`
- ارسال تراکنش و نمایش نتایج
- نمایش توانایی سیستم در استفاده از چندریختی (polymorphism)


## گسترش‌پذیری

برای افزودن درگاه جدید (مثلاً درگاه زرین‌پال یا Square)، کافی است یک کلاس جدید ایجاد کرده و رابط `PaymentGateway` را پیاده‌سازی کنید. بدون نیاز به تغییر در منطق اصلی.

</div>
